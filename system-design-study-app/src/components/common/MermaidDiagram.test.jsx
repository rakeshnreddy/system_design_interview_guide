import React from 'react';
import { render, screen, act } from '@testing-library/react';
import '@testing-library/jest-dom';
import MermaidDiagram from './MermaidDiagram';
import { vi } from 'vitest';

// Mock the Card component
vi.mock('./Card', () => ({
  default: ({ children, ...rest }) => <div data-testid="card" {...rest}>{children}</div>
}));

describe('MermaidDiagram', () => {
  const mockDiagramDefinition = 'graph TD;\nA-->B;';
  let mockMermaidAPI;

  beforeEach(() => {
    // Reset the global mermaid object and its initialized state for each test
    mockMermaidAPI = {
      initialize: vi.fn(),
      // Mock render to return a Promise resolving to an object with an svg property
      render: vi.fn().mockImplementation(async (id, definition) => {
        // console.log(`Mock render called with id: ${id}, definition: ${definition}`);
        if (definition.includes("error")) {
          throw new Error('Test render error');
        }
        return Promise.resolve({ svg: `<svg data-testid="${id.includes('new') ? 'mermaid-svg-new' : 'mermaid-svg'}"></svg>`, bindFunctions: () => {} });
      }),
      isInitialized: false, // Ensure this is reset
    };
    window.mermaid = mockMermaidAPI;
  });

  afterEach(() => {
    // Clean up the global mermaid object
    delete window.mermaid;
    // Clean up any temporary divs that might be left in the body from tests
    const tempElements = document.querySelectorAll('[id^="render-temp-mermaid-"]');
    tempElements.forEach(el => el.remove());
  });

  test('renders Card component', () => {
    render(<MermaidDiagram diagramDefinition={mockDiagramDefinition} diagramId="test1" />);
    expect(screen.getByTestId('card')).toBeInTheDocument();
  });

  test('initializes Mermaid if not already initialized', () => {
    render(<MermaidDiagram diagramDefinition={mockDiagramDefinition} diagramId="test-init" />);
    expect(mockMermaidAPI.initialize).toHaveBeenCalledWith({
      startOnLoad: false,
      theme: 'default',
    });
    expect(mockMermaidAPI.isInitialized).toBe(true);
  });

  test('does not re-initialize Mermaid if already initialized', () => {
    window.mermaid.isInitialized = true; // Simulate already initialized
    render(<MermaidDiagram diagramDefinition={mockDiagramDefinition} diagramId="test-no-reinit" />);
    expect(mockMermaidAPI.initialize).not.toHaveBeenCalled();
  });

  test('calls mermaid.render with diagram definition and renders SVG', async () => {
    await act(async () => {
      render(<MermaidDiagram diagramDefinition={mockDiagramDefinition} diagramId="test-render" />);
    });
    // Check that render was called. The first argument is a generated ID.
    expect(mockMermaidAPI.render).toHaveBeenCalledWith(
      "mermaid-test-render-svg",
      mockDiagramDefinition
    );
    expect(screen.getByTestId('mermaid-svg')).toBeInTheDocument();
  });

  test('clears previous diagram when definition changes', async () => {
    const { rerender } = render(<MermaidDiagram diagramDefinition={mockDiagramDefinition} diagramId="test-change" />);
    await screen.findByTestId('mermaid-svg'); // Ensure initial render completes

    const newDefinition = 'graph LR;\nC-->D;';
    // Mock for the new definition
    mockMermaidAPI.render.mockImplementationOnce(async (id, definition) => {
        return Promise.resolve({ svg: `<svg data-testid="mermaid-svg-new"></svg>`, bindFunctions: () => {} });
    });

    await act(async () => {
      rerender(<MermaidDiagram diagramDefinition={newDefinition} diagramId="test-change" />);
    });

    await screen.findByTestId('mermaid-svg-new');
    expect(screen.queryByTestId('mermaid-svg')).not.toBeInTheDocument();
    expect(mockMermaidAPI.render).toHaveBeenCalledWith(
      "mermaid-test-change-svg", // ID generated by component for the new render
      newDefinition
    );
  });

  test('displays error message if mermaid rendering fails', async () => {
    // Update mock to throw error for this specific test case
    mockMermaidAPI.render.mockImplementationOnce(async () => {
      throw new Error('Test render error');
    });

    await act(async () => {
      render(<MermaidDiagram diagramDefinition={mockDiagramDefinition} diagramId="test-error" />);
    });
    expect(screen.getByText(/Error rendering diagram: Test render error/)).toBeInTheDocument();
  });

  test('displays message if mermaid library is not available', async () => {
    delete window.mermaid;
    await act(async () => {
      render(<MermaidDiagram diagramDefinition={mockDiagramDefinition} diagramId="test-no-mermaid" />);
    });
    // The component now has a setTimeout for retrying, so we might need to wait or check for the initial message
    expect(screen.getByText('Mermaid library not available yet. Retrying...')).toBeInTheDocument();
  });

  test('clears container if diagramDefinition is empty or null', async () => {
    const { rerender } = render(<MermaidDiagram diagramDefinition={mockDiagramDefinition} diagramId="test-clear" />);
    await screen.findByTestId('mermaid-svg'); // Wait for initial render

    await act(async () => {
      rerender(<MermaidDiagram diagramDefinition="" diagramId="test-clear" />);
    });
    expect(screen.queryByTestId('mermaid-svg')).not.toBeInTheDocument();

    await act(async () => {
      rerender(<MermaidDiagram diagramDefinition={null} diagramId="test-clear" />);
    });
    expect(screen.queryByTestId('mermaid-svg')).not.toBeInTheDocument();
  });

   test('handles cases where containerRef might become null during async rendering (though unlikely with normal flow)', async () => {
    const { unmount } = render(<MermaidDiagram diagramDefinition={mockDiagramDefinition} diagramId="test-unmount" />);

    mockMermaidAPI.render.mockImplementationOnce((id, definition, callback) => {
      // Simulate unmount before callback
      unmount();
      // Callback is called after unmount, containerRef.current would be null
      // We are testing that this doesn't throw an error inside the callback
      expect(() => callback('<svg></svg>')).not.toThrow();
    });

    // Re-trigger useEffect by changing a prop; this is a bit artificial for this exact scenario
    // but helps simulate the async nature if render was delayed.
    // In a real scenario, the component unmounting during an async mermaid.render callback is the concern.
    await act(async () => {
       render(<MermaidDiagram diagramDefinition={mockDiagramDefinition + " "} diagramId="test-unmount" />);
    });
    // No explicit assertion needed other than not throwing, which is covered by the expect in mock.
  });


});
